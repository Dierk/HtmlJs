<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>3D Tetris</title>
    <link rel="stylesheet" href="../scene.css">
    <style>

        :root {
            --box-width:        6;
        }

        body {
            min-height:             100dvh;
            display:                grid;
            grid-template-columns:  100%;
            grid-template-rows:     1fr max-content;
            margin:                 0;
            background:             linear-gradient(in srgb-linear, blue, orange);
        }

        footer {
            padding:            1lh;
            display:            grid;
            place-items:        center;
            color:              white;
            font-size:          120%;
        }
        .floor {
            position:           absolute;
            inset:              0;
            width:              100%;
            height:             100%;
            background-image:   repeating-conic-gradient(transparent 0deg 90deg, black 90deg 180deg);
            background-size:    calc(var(--box-width) * 2 *1cqmin) calc(var(--box-width) * 2 * 1cqmin);
            opacity:            0.3;
            & .toplight {
                position:           absolute;
                inset:              0;
                background-image:   radial-gradient(white 30% ,black 80%);
                opacity:            .85;
            }
        }

        .tetromino {
            transform-style:    preserve-3d;
            grid-area:          1/1;
            display:            grid;
            --z-center:         calc(1cqmin * var(--box-width) / 2);
            --tetromino-x:      0;
            --tetromino-y:      0;
            --tetromino-z:      0;
            translate:          calc(var(--tetromino-x) * var(--box-width) * 1cqmin)
                                calc(var(--tetromino-y) * var(--box-width) * 1cqmin)
                                calc(var(--tetromino-z) * var(--box-width) * 1cqmin + var(--z-center));
            transition:         translate .2s linear;
        }

        /* provides the logical group */
         .box {
             grid-area:          1/1;
             --x:                0;
             --y:                0;
             --z:                0;
             width:              calc(var(--box-width) * 1cqmin);
             aspect-ratio:       1 / 1;
             display:            grid;                              /* child positioning  */
             transform-style:    preserve-3d;                       /* put children in our 3d space */
             translate:          calc(var(--x) * var(--box-width) * 1cqmin)
                                 calc(var(--y) * var(--box-width) * 1cqmin)
                                 calc(var(--z) * var(--box-width) * 1cqmin);
             transition:         all .1s linear;
         }

         /* all children go directly on top of each other */
         .box > * {
             grid-area:          1/1;
             background:         grey;
             opacity:            .8;
             border-radius:      3%;
             border:             1px solid grey;
         }

         /* the transform origin for rotate is center by default, so rotations must first */
         /* put the respective face in the the center, then rotate.            */
         .box :nth-child(1) {transform:                 translateZ(var(--z-center));}  /* move front to center */
         .box :nth-child(2) {transform: rotateY(180deg) translateZ(var(--z-center));}  /* center, then around Y-axis to the back */
         .box :nth-child(3) {transform: rotateY(-90deg) translateZ(var(--z-center));}  /* center, then around Y-axis to the left */
         .box :nth-child(4) {transform: rotateY( 90deg) translateZ(var(--z-center));}  /* center, then around Y-axis to the right */
         .box :nth-child(5) {transform: rotateX( 90deg) translateZ(var(--z-center));}  /* center, then around X-axis to the top */
         .box :nth-child(6) {transform: rotateX(-90deg) translateZ(var(--z-center));}  /* center, then around X-axis to the bottom */

        .shapeI .box * {
            background-color: cyan;
        }
        .shapeT .box * {
            background-color: red;
        }
    </style>
</head>
<body>
<main id="main" class="scene3d noSelection">
    <div class="coords" style="
            --coords-rotate-x:  86;
            --coords-rotate-y: -15;
            top:                70cqh;
    ">
        <div class="floor"><div class="toplight"></div></div>

        <div class="tetromino shapeI" data-id="0" style="--tetromino-x: 0;--tetromino-y: 0;--tetromino-z: 0;">
            <div class="box" style="--x: 0;--y: 0;--z: 0;"><div></div><div></div><div></div><div></div><div></div><div></div></div>
            <div class="box" style="--x: 0;--y: 0;--z: 0;"><div></div><div></div><div></div><div></div><div></div><div></div></div>
            <div class="box" style="--x: 0;--y: 0;--z: 0;"><div></div><div></div><div></div><div></div><div></div><div></div></div>
            <div class="box" style="--x: 0;--y: 0;--z: 0;"><div></div><div></div><div></div><div></div><div></div><div></div></div>
        </div>
        <div class="tetromino shapeT" data-id="1" style="--tetromino-x: 0;--tetromino-y: 0;--tetromino-z: 0;">
            <div class="box" style="--x: 0;--y: 0;--z: 0;"><div></div><div></div><div></div><div></div><div></div><div></div></div>
            <div class="box" style="--x: 0;--y: 0;--z: 0;"><div></div><div></div><div></div><div></div><div></div><div></div></div>
            <div class="box" style="--x: 0;--y: 0;--z: 0;"><div></div><div></div><div></div><div></div><div></div><div></div></div>
            <div class="box" style="--x: 0;--y: 0;--z: 0;"><div></div><div></div><div></div><div></div><div></div><div></div></div>
        </div>

    </div>
</main>
<footer>
    Use mouse or touch to rotate the coords.
    Arrow keys to move the tetromino.
    Shift + arrow keys to rotate.
</footer>

<script type="module">
    import { registerForMouseAndTouch }     from "./scene.js";
    import { toppleTetroLeft }           from "./controller.js";
    import { shapeITetros,shapeTTetros } from "./model.js";

    registerForMouseAndTouch(main);


    const makeShapes = (shapeModel, dim) => {
        const result = [ ]; // it's always possible to go four times to the left
        result[0] = shapeModel;
        result[1] = result[0].map( shape => toppleTetroLeft(shape, dim));
        result[2] = result[1].map( shape => toppleTetroLeft(shape, dim));
        result[3] = result[2].map( shape => toppleTetroLeft(shape, dim));
        return result;
    }

    const tetrominos = [
        {
            position:       {x:0, y:0, z:0},
            shape:          makeShapes(shapeITetros, 4) ,
            leftTopples:    0,
            frontTopples:   0,
        },
        {
            position:       {x:0, y:5, z:0},
            shape:          makeShapes(shapeTTetros,3) ,
            leftTopples:    0,
            frontTopples:   0,
        },
    ];

    const move = tetro => {
        const position = tetro.position;
        document.querySelector(`[data-id="${tetrominos.indexOf(tetro)}"]`).setAttribute("style",
            `--tetromino-x: ${position.x};
             --tetromino-y: ${position.y};
             --tetromino-z: ${position.z};`
        );
    }
    const align = tetro => {
        const tetroView = document.querySelector(`[data-id="${tetrominos.indexOf(tetro)}"]`);
        const curShape  = tetro.shape[tetro.leftTopples][tetro.frontTopples];
        tetroView.querySelectorAll(".box").forEach( (box, idx) => {
            box.setAttribute("style",
                `--x: ${curShape[idx].x};
                 --y: ${curShape[idx].y};
                 --z: ${curShape[idx].z};`
            );
        })
    }

    const rotateToBack  = tetro => {
        tetro.leftTopples = (tetro.leftTopples + 1) % tetro.shape.length;
    }
    const rotateToFront = tetro => {
        tetro.leftTopples = tetro.leftTopples < 1
            ?  tetro.shape.length - 1
            :  tetro.leftTopples - 1;
    }
    const toppleRight = tetro => {
        tetro.frontTopples = (tetro.frontTopples + 1) % tetro.shape[tetro.leftTopples].length;
    }
    const toppleLeft    = tetro => {
        tetro.frontTopples = tetro.frontTopples < 1
            ?  tetro.shape[tetro.leftTopples].length - 1
            :  tetro.frontTopples - 1;
    }

    document.onkeydown = keyEvt => {
        const tetro = currentTetromino;
        if (keyEvt.shiftKey) {
            switch (keyEvt.key) {
                case "Shift":       break; // ignore the initial shift signal
                case "ArrowRight":  toppleRight  (tetro); align(tetro); break; // front topples clockwise
                case "ArrowLeft":   toppleLeft   (tetro); align(tetro); break; // front topples counter-clockwise
                case "ArrowUp":     rotateToBack (tetro); align(tetro); break; // top layer moves to the back
                case "ArrowDown":   rotateToFront(tetro); align(tetro); break; // top layer moves to the front
                default:            console.warn("unknown key" ,keyEvt.key);
            }
        } else {
            const pos = tetro.position;
            switch (keyEvt.key) {
                case "ArrowLeft":   pos.x = pos.x-1; move(tetro);   break;
                case "ArrowRight":  pos.x = pos.x+1; move(tetro);   break;
                case "ArrowUp":     pos.y = pos.y-1; move(tetro);   break;
                case "ArrowDown":   pos.y = pos.y+1; move(tetro);   break;
                default:            console.warn("unknown key" ,keyEvt.key);
            }
        }

    }

    // init view
    tetrominos.forEach( tetro => {
        align(tetro);
        move(tetro);
    })

    const currentTetromino = tetrominos[0];

    let i = 10;
    const fall = () => {
        if (--i < 0) return;
        currentTetromino.position.z = i;
        move(currentTetromino);
        setTimeout(fall, 1 * 1000);
    }
    fall();





</script>
</body>
</html>
