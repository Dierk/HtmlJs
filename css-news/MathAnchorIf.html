<!DOCTYPE HTML>
<html lang="en">

<!--original: https://codepen.io/t_afif/pen/wBWWKxP-->

<head>
    <title>Math Spring Attr</title>
    <style>

        @property --_m0 {
            syntax:        "<integer>";
            initial-value: 1;
            inherits:      true
        }


        /* keep the shared information in the common parent of anchor and circles */
        body {
            --anchor-name-a: --a;
            --anchor-name-b: --b;
            --diameter-a:    170px;
            --diameter-b:    100px;
        }


        .circle {
            position:      absolute;
            aspect-ratio:  1;
            border-radius: 50%;
        }

        /* while the circles have only their role and their specifics */

        .circle:nth-child(1) {
            anchor-name:   var(--anchor-name-a);
            width:         var(--diameter-a);
            background:    green;
            left:          10%;
            top:           10%;
        }

        .circle:nth-child(2) {
            anchor-name:   var(--anchor-name-b);
            width:         var(--diameter-b);
            background:    red;
            left:          72%;
            top:           40%;
        }


        .arrow {
            pointer-events: none;

          /* arrow dimension */
          --r: 25px;  /* radius: side length of the arrowhead */
          --a: 40deg; /* pointiness of the arrowhead */
          --d: 5px;   /* diameter: thickness of the arrow bar */

          --g: 10px; /* gap between the arrow and circles */
          --c: grey;

          /* radius is half the circle width plus gap  */
          --r1: calc( var(--diameter-a) / 2 + var(--g));
          --r2: calc( var(--diameter-b) / 2 + var(--g));
        }

        /* there are 4 arrow children for the 4 possible layout quadrants in which */
        /* the arrow might need to be positioned in */

        .arrow > * {
            container-type: size;
            position:       absolute;
            display:        grid;

            /*
            The value of "inside" will be resolved lazily, when it is clear which "inset"
            (left,right,top,bottom) is to be set.
            Pretty nifty.
            */

            --_x: calc(anchor(var(--anchor-name-a) inside) + anchor-size(var(--anchor-name-a)) / 2 );
            --_y: calc(anchor(var(--anchor-name-b) inside) + anchor-size(var(--anchor-name-b)) / 2);
        }
/*
        The size and position of each quadrant is calculated via anchor positioning.
        The first quadrant "a" in the upper left corner has its
           left side in the middle of x,
           the right side at the middle of y,
           the top at the middle of x,
           and the bottom at the middle of y.
        What is used as the side boundaries
        changes with the quadrants.
*/

        .arrow :is(:nth-child(1),:nth-child(2)) {top:  var(--_x); bottom: var(--_y)}
        .arrow :is(:nth-child(1),:nth-child(3)) {left: var(--_x); right:  var(--_y)}
        .arrow :is(:nth-child(3),:nth-child(4)) {top:  var(--_y); bottom: var(--_x)}
        .arrow :is(:nth-child(2),:nth-child(4)) {left: var(--_y); right:  var(--_x)}

        .arrow :is(:nth-child(1),:nth-child(2),:nth-child(3),:nth-child(4)):before {
          content: "";
          border-image: conic-gradient(var(--c)) fill 0//900px;
          --_a: atan(100cqh/100cqw);
          --_aa: atan(var(--d)/(var(--r)*cos(var(--a))));
          --_m0: max(sign(100cqh/sin(var(--_a)) - (var(--r1) + var(--r2) + 4*var(--r))),0);
          --_m1: max(sign(100cqh/sin(var(--_a)) - (var(--r1) + var(--r2) - 2*var(--g))),0);
          opacity: calc(sign(1cqw)*sign(1cqh)*var(--_m1));
          clip-path: if(style(--_m0: 1):
            polygon(
              calc((var(--d)/sin(var(--_aa)))*cos(var(--_a) - var(--_aa)))
              calc((var(--d)/sin(var(--_aa)))*sin(var(--_a) - var(--_aa))),
              calc(var(--r)*cos(var(--_a) - var(--a)))
              calc(var(--r)*sin(var(--_a) - var(--a))),
              0 0,
              calc(var(--r)*cos(var(--_a) + var(--a)))
              calc(var(--r)*sin(var(--_a) + var(--a))),
              calc((var(--d)/sin(var(--_aa)))*cos(var(--_a) + var(--_aa)))
              calc((var(--d)/sin(var(--_aa)))*sin(var(--_a) + var(--_aa))),
              calc(100% - (var(--d)/sin(var(--_aa)))*cos(var(--_a) - var(--_aa)))
              calc(100% - (var(--d)/sin(var(--_aa)))*sin(var(--_a) - var(--_aa))),
              calc(100% - (var(--r))*cos(var(--_a) - var(--a)))
              calc(100% - (var(--r))*sin(var(--_a) - var(--a))),
              100% 100%,
              calc(100% - (var(--r))*cos(var(--_a) + var(--a)))
              calc(100% - (var(--r))*sin(var(--_a) + var(--a))),
              calc(100% - (var(--d)/sin(var(--_aa)))*cos(var(--_a) + var(--_aa)))
              calc(100% - (var(--d)/sin(var(--_aa)))*sin(var(--_a) + var(--_aa)))
            );
            else:
            shape(
              from   calc(100% - var(--r)*cos(var(--_a) - atan(2*var(--d)/var(--r)))/2)
                     calc(100% - var(--r)*sin(var(--_a) - atan(2*var(--d)/var(--r)))/2),
              arc to calc(100% - var(--r)*cos(var(--_a) + atan(2*var(--d)/var(--r)))/2)
                     calc(100% - var(--r)*sin(var(--_a) + atan(2*var(--d)/var(--r)))/2) of calc(var(--r)/2) large,
              line to calc(var(--r)*cos(var(--_a) - atan(2*var(--d)/var(--r)))/2)
                      calc(var(--r)*sin(var(--_a) - atan(2*var(--d)/var(--r)))/2),
              arc to  calc(var(--r)*cos(var(--_a) + atan(2*var(--d)/var(--r)))/2)
                      calc(var(--r)*sin(var(--_a) + atan(2*var(--d)/var(--r)))/2) of calc(var(--r)/2) large,
            ););
        }
        .arrow :nth-child(1):before {
          margin:
            calc(var(--_m0)*sin(var(--_a))*var(--r1))
            calc(var(--_m0)*cos(var(--_a))*var(--r2))
            calc(var(--_m0)*sin(var(--_a))*var(--r2))
            calc(var(--_m0)*cos(var(--_a))*var(--r1));
        }
        .arrow :nth-child(2):before {
          margin:
            calc(var(--_m0)*sin(var(--_a))*var(--r1))
            calc(var(--_m0)*cos(var(--_a))*var(--r1))
            calc(var(--_m0)*sin(var(--_a))*var(--r2))
            calc(var(--_m0)*cos(var(--_a))*var(--r2));
          scale: -1 1;
        }
        .arrow :nth-child(3):before {
          margin:
            calc(var(--_m0)*sin(var(--_a))*var(--r2))
            calc(var(--_m0)*cos(var(--_a))*var(--r2))
            calc(var(--_m0)*sin(var(--_a))*var(--r1))
            calc(var(--_m0)*cos(var(--_a))*var(--r1));
          scale: 1 -1;
        }
        .arrow :nth-child(4):before {
          margin:
            calc(var(--_m0)*sin(var(--_a))*var(--r2))
            calc(var(--_m0)*cos(var(--_a))*var(--r1))
            calc(var(--_m0)*sin(var(--_a))*var(--r1))
            calc(var(--_m0)*cos(var(--_a))*var(--r2));
          scale: -1 -1;
        }

        .arrow :is(:nth-child(1),:nth-child(2),:nth-child(3),:nth-child(4)):after {
          content: counter(dis);
          counter-reset: dis var(--_d);
          position: absolute;
          --_a: atan(100cqh/100cqw);
          --_m0: max(sign(100cqh/sin(var(--_a)) - (var(--r1) + var(--r2) + 4*var(--r))),0);
          --_m1: max(sign(100cqh/sin(var(--_a)) - (var(--r1) + var(--r2) - 2*var(--g))),0);
          opacity: calc(sign(1cqw)*sign(1cqh)*var(--_m1));
          --_d: calc((100cqh/sin(var(--_a)) - var(--r1) - var(--r2) + 2*var(--g))/1px);
          place-self: center;
          rotate: var(--_a);
          translate: calc(cos(var(--_a))*(var(--r1) - var(--r2))/2) calc(sin(var(--_a))*(var(--r1) - var(--r2))/2);
          background: var(--c);
          padding: 5px 10px;
          border-radius: calc(var(--_m0)*4px);
          color: if(style(--_m0: 1):#fff;else:pink);
          font: bold 20px system-ui, sans-serif;
        }
        .arrow :nth-child(2):after {
          rotate: calc(-1*var(--_a));
          translate: calc(cos(var(--_a))*(var(--r2) - var(--r1))/2) calc(sin(var(--_a))*(var(--r2) - var(--r1))/-2);
        }
        .arrow :nth-child(3):after {
          rotate: calc(-1*var(--_a));
          translate: calc(cos(var(--_a))*(var(--r1) - var(--r2))/2) calc(sin(var(--_a))*(var(--r1) - var(--r2))/-2);
        }
        .arrow :nth-child(4):after {
          translate: calc(cos(var(--_a))*(var(--r2) - var(--r1))/2) calc(sin(var(--_a))*(var(--r2) - var(--r1))/2);
        }


    </style>
</head>

<body>
Chrome only (Jan 26)


<div class="circle" ></div>
<div class="circle" ></div>

<div class="arrow">
  <div></div>
  <div></div>
  <div></div>
  <div></div>
</div>

<script>

    /* The JS code is only here to move a dom element (here a circle) with the mouse. */

    const circles = document.querySelectorAll('.circle');

    for (const circle of circles) {
        circle._active = false;     // whether this circle is to be moved (reacts to current mouse move)
        circle._xDiff = 0;          // diff between mouse position and circle bounds
        circle._yDiff = 0;

        circle.addEventListener('mousedown', mouseEvent => {
            circle._active  = true;
            const rect      = circle.getBoundingClientRect();
            circle._xDiff   = mouseEvent.clientX - rect.left;
            circle._yDiff   = mouseEvent.clientY - rect.top;
        });
    }

    // We register the mouse move listener on the document rather than the specific circle
    // to allow quick mouse movement across the element border without losing track
    document.addEventListener('mousemove', mouseEvent => {
        circles.forEach( circle =>  {
            if ( ! circle._active) return;
            circle.style.left = (mouseEvent.clientX - circle._xDiff) + 'px';
            circle.style.top  = (mouseEvent.clientY - circle._yDiff) + 'px';
      });
    });
    // it's actually quicker to just go over all circles instead of only the active ones
    document.addEventListener('mouseup', _e => circles.forEach(circle => circle._active = false));

</script>

</body>

</html>
