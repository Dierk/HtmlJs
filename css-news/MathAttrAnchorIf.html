<!DOCTYPE HTML>
<html lang="en">

<!--original: https://codepen.io/t_afif/pen/wBWWKxP-->

<head>
    <title>Math Spring Attr</title>
    <style>

        @property --_m0 {syntax: "<integer>";initial-value: 1;inherits: true}

        .arrow {
          /* arrow dimension */
          --r: 25px;
          --a: 40deg;
          --d: 5px;
          /**/
          --g: 10px; /* gap between the arrow and circles */
          --c: #556270;
          pointer-events: none;
          --x: attr(data-x type(<custom-ident>));
          --y: attr(data-y type(<custom-ident>));
          --r1: calc(attr(data-size_x type(<length>))/2 + var(--g));
          --r2: calc(attr(data-size_y type(<length>))/2 + var(--g));
        }

        .arrow :is(a,b,c,d) {
          position: absolute;
          display: grid;
          --_x: calc(anchor(var(--x) inside) + anchor-size(var(--x))/2 - .1px);
          --_y: calc(anchor(var(--y) inside) + anchor-size(var(--y))/2);
          container-type: size;
        }
        .arrow :is(a,b) {top:  var(--_x); bottom: var(--_y)}
        .arrow :is(a,c) {left: var(--_x); right:  var(--_y)}
        .arrow :is(c,d) {top:  var(--_y); bottom: var(--_x)}
        .arrow :is(b,d) {left: var(--_y); right:  var(--_x)}

        .arrow :is(a,b,c,d):before {
          content: "";
          border-image: conic-gradient(var(--c)) fill 0//900px;
          --_a: atan(100cqh/100cqw);
          --_aa: atan(var(--d)/(var(--r)*cos(var(--a))));
          --_m0: max(sign(100cqh/sin(var(--_a)) - (var(--r1) + var(--r2) + 4*var(--r))),0);
          --_m1: max(sign(100cqh/sin(var(--_a)) - (var(--r1) + var(--r2) - 2*var(--g))),0);
          opacity: calc(sign(1cqw)*sign(1cqh)*var(--_m1));
          clip-path: if(style(--_m0: 1):
            polygon(
              calc((var(--d)/sin(var(--_aa)))*cos(var(--_a) - var(--_aa)))
              calc((var(--d)/sin(var(--_aa)))*sin(var(--_a) - var(--_aa))),
              calc(var(--r)*cos(var(--_a) - var(--a)))
              calc(var(--r)*sin(var(--_a) - var(--a))),
              0 0,
              calc(var(--r)*cos(var(--_a) + var(--a)))
              calc(var(--r)*sin(var(--_a) + var(--a))),
              calc((var(--d)/sin(var(--_aa)))*cos(var(--_a) + var(--_aa)))
              calc((var(--d)/sin(var(--_aa)))*sin(var(--_a) + var(--_aa))),
              calc(100% - (var(--d)/sin(var(--_aa)))*cos(var(--_a) - var(--_aa)))
              calc(100% - (var(--d)/sin(var(--_aa)))*sin(var(--_a) - var(--_aa))),
              calc(100% - (var(--r))*cos(var(--_a) - var(--a)))
              calc(100% - (var(--r))*sin(var(--_a) - var(--a))),
              100% 100%,
              calc(100% - (var(--r))*cos(var(--_a) + var(--a)))
              calc(100% - (var(--r))*sin(var(--_a) + var(--a))),
              calc(100% - (var(--d)/sin(var(--_aa)))*cos(var(--_a) + var(--_aa)))
              calc(100% - (var(--d)/sin(var(--_aa)))*sin(var(--_a) + var(--_aa)))
            );
            else:
            shape(
              from   calc(100% - var(--r)*cos(var(--_a) - atan(2*var(--d)/var(--r)))/2)
                     calc(100% - var(--r)*sin(var(--_a) - atan(2*var(--d)/var(--r)))/2),
              arc to calc(100% - var(--r)*cos(var(--_a) + atan(2*var(--d)/var(--r)))/2)
                     calc(100% - var(--r)*sin(var(--_a) + atan(2*var(--d)/var(--r)))/2) of calc(var(--r)/2) large,
              line to calc(var(--r)*cos(var(--_a) - atan(2*var(--d)/var(--r)))/2)
                      calc(var(--r)*sin(var(--_a) - atan(2*var(--d)/var(--r)))/2),
              arc to  calc(var(--r)*cos(var(--_a) + atan(2*var(--d)/var(--r)))/2)
                      calc(var(--r)*sin(var(--_a) + atan(2*var(--d)/var(--r)))/2) of calc(var(--r)/2) large,
            ););
        }
        .arrow a:before {
          margin:
            calc(var(--_m0)*sin(var(--_a))*var(--r1))
            calc(var(--_m0)*cos(var(--_a))*var(--r2))
            calc(var(--_m0)*sin(var(--_a))*var(--r2))
            calc(var(--_m0)*cos(var(--_a))*var(--r1));
        }
        .arrow b:before {
          margin:
            calc(var(--_m0)*sin(var(--_a))*var(--r1))
            calc(var(--_m0)*cos(var(--_a))*var(--r1))
            calc(var(--_m0)*sin(var(--_a))*var(--r2))
            calc(var(--_m0)*cos(var(--_a))*var(--r2));
          scale: -1 1;
        }
        .arrow c:before {
          margin:
            calc(var(--_m0)*sin(var(--_a))*var(--r2))
            calc(var(--_m0)*cos(var(--_a))*var(--r2))
            calc(var(--_m0)*sin(var(--_a))*var(--r1))
            calc(var(--_m0)*cos(var(--_a))*var(--r1));
          scale: 1 -1;
        }
        .arrow d:before {
          margin:
            calc(var(--_m0)*sin(var(--_a))*var(--r2))
            calc(var(--_m0)*cos(var(--_a))*var(--r1))
            calc(var(--_m0)*sin(var(--_a))*var(--r1))
            calc(var(--_m0)*cos(var(--_a))*var(--r2));
          scale: -1 -1;
        }

        .arrow :is(a,b,c,d):after {
          content: counter(dis);
          counter-reset: dis var(--_d);
          position: absolute;
          --_a: atan(100cqh/100cqw);
          --_m0: max(sign(100cqh/sin(var(--_a)) - (var(--r1) + var(--r2) + 4*var(--r))),0);
          --_m1: max(sign(100cqh/sin(var(--_a)) - (var(--r1) + var(--r2) - 2*var(--g))),0);
          opacity: calc(sign(1cqw)*sign(1cqh)*var(--_m1));
          --_d: calc((100cqh/sin(var(--_a)) - var(--r1) - var(--r2) + 2*var(--g))/1px);
          place-self: center;
          rotate: var(--_a);
          translate: calc(cos(var(--_a))*(var(--r1) - var(--r2))/2) calc(sin(var(--_a))*(var(--r1) - var(--r2))/2);
          background: var(--c);
          padding: 5px 10px;
          border-radius: calc(var(--_m0)*4px);
          color: if(style(--_m0: 1):#fff;else:pink);
          font: bold 20px system-ui, sans-serif;
        }
        .arrow b:after {
          rotate: calc(-1*var(--_a));
          translate: calc(cos(var(--_a))*(var(--r2) - var(--r1))/2) calc(sin(var(--_a))*(var(--r2) - var(--r1))/-2);
        }
        .arrow c:after {
          rotate: calc(-1*var(--_a));
          translate: calc(cos(var(--_a))*(var(--r1) - var(--r2))/2) calc(sin(var(--_a))*(var(--r1) - var(--r2))/-2);
        }
        .arrow d:after {
          translate: calc(cos(var(--_a))*(var(--r2) - var(--r1))/2) calc(sin(var(--_a))*(var(--r2) - var(--r1))/2);
        }

        .circle {
          position: absolute;
          left: 10%;
          top: 10%;
          width: calc(attr(data-size type(<length>)));
          aspect-ratio: 1;
          background: #45ADA8;
          border-radius: 50%;
          anchor-name: attr(data-name type(<custom-ident>));
        }
        .circle + .circle {
          background: #FA6900;
          left: 72%;
          top: 40%;
        }




    </style>
</head>

<body>
Chrome only (Jan 26)


<div class="circle" data-name="--a" data-size="170px"></div>
<div class="circle" data-name="--b" data-size="100px"></div>

<div class="arrow" data-x="--a" data-y="--b" data-size_x="170px" data-size_y="100px">
  <a></a>
  <b></b>
  <c></c>
  <d></d>
</div>

<script>

    /* The JS code is only here to move a dom element (here a circle) with the mouse. */

    const circles = document.querySelectorAll('.circle');

    for (const circle of circles) {
        circle._active = false;     // whether this circle is to be moved (reacts to current mouse move)
        circle._xDiff = 0;          // diff between mouse position and circle bounds
        circle._yDiff = 0;

        circle.addEventListener('mousedown', mouseEvent => {
            circle._active  = true;
            const rect      = circle.getBoundingClientRect();
            circle._xDiff   = mouseEvent.clientX - rect.left;
            circle._yDiff   = mouseEvent.clientY - rect.top;
        });
    }

    // We register the mouse move listener on the document rather than the specific circle
    // to allow quick mouse movement across the element border without losing track
    document.addEventListener('mousemove', mouseEvent => {
        circles.forEach( circle =>  {
            if ( ! circle._active) return;
            circle.style.left = (mouseEvent.clientX - circle._xDiff) + 'px';
            circle.style.top  = (mouseEvent.clientY - circle._yDiff) + 'px';
      });
    });
    // it's actually quicker to just go over all circles instead of only
    document.addEventListener('mouseup', _e => circles.forEach(circle => circle._active = false));

</script>

</body>

</html>
