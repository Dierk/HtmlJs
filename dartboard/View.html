<!DOCTYPE html>
<html>
<head>
    <title>View</title>
    <script src="../observable/observable.js"></script>
    <script src="dartboard.js"></script>
    <style>
        body {
            background: palegoldenrod;
        }
        canvas {
            margin: 0.1em 1em 0 1em;
            --dartboard-color-ring0 :    red;
            --dartboard-color-ring1 :    lightblue;
            --dartboard-color-ring2 :    blue;
            --dartboard-color-ring3 :    darkblue;
            --dartboard-color-selected:  black;
            --dartboard-no-color    :    rgba(255,255,255,0.2);
        }
        label {
            padding-right: 0.8em;
            padding-left:  0.8em;
        }
        #dartList {
            display: grid;
            grid: auto / auto ;
        }
        div.widget {
            float: left;
        }
        .selected {
            border: 2px solid orange;
            border-radius: 4px;
        }
    </style>

</head>
<body>


<div class="widget">
    <canvas id="dartView" width="400" height="400"></canvas>
</div>

<div class="widget">
    <div id="dartList"></div>
</div>

<div class="widget">
    <button onclick="dartController.addSegment(0,'change me')"> add and select segment</button>
    <button onclick="dartController.removeSelectedSegment();"> remove selected segment</button>
</div>

<div class="widget">
    <pre>

    Butterfly ideas:
    - keep the model identities such that the view can bind *read-only* in a stable fashion (observable)
    - keep the view  identities (go around issues with the view state)

    - views never write into the model, they send a command to the controller
    - commands are processed in strict sequence (special issue: callbacks from asynchronous calls)
    - since the controller is the only one that can write into the model, he can also savely read

    - a controller has no access to the view
    - all information that a controller needs must be in the model (from previous commands) or given as command attributes


    </pre>
</div>

<script>

    // model // this will later go into two modules, one for reading only (for the views) and one for read/write (for the controllers)

    const model = {
        selectedIndex: Observable(-1),      // -1 means no selection, todo: consider Nothing
        segments:      ObservableList([])   // list of Observable {value: , label:} entries
    };

    // Controller      // dependency injection done right :-)
    const Controller = model => {                           // make a local scope. This will later go into a module

        const addSegment = (value, label = "change me") => {
            model.segments.add(Observable({value: value, label: label}));
            selectLastIndex();
        };
        /** private */
        const removeSegment = index => {
            if (! isValidIndex(index)) return;
            model.segments.delIndex(index);
            if (isSelected(index)) {  // business rule: after removal we select the previous segment if any
                selectIndex(index > 0 ? index - 1 : 0);
            }
        };

        const removeSelectedSegment = () => removeSegment(model.selectedIndex.getValue());
        const selectIndex  = index => isValidIndex(index) && model.selectedIndex.setValue(index);
        const isValidIndex = index => (index >=0 && index < model.segments.count());                // private
        const isSelected   = index => index === model.selectedIndex.getValue();                     // private
        const selectLastIndex = () => selectIndex(model.segments.count() - 1);                      // private

        const setSegmentValue = obsSegment => value => obsSegment.setValue({value: value, label: obsSegment.getValue().label} );
        const setSegmentLabel = obsSegment => label => obsSegment.setValue({value: obsSegment.getValue().value, label: label} );

        // public API for the views to work with
        return {
            addSegment:     addSegment,
            removeSelectedSegment: removeSelectedSegment,
            selectIndex:     selectIndex,
            setSegmentValue: setSegmentValue,
            setSegmentLabel: setSegmentLabel,
        }
    };
    const dartController = Controller(model);

    // register the listeners ------------

    // view constants:
    const dartView = document.getElementById("dartView");
    const dartList = document.getElementById("dartList");

    // dartList listeners:

    const showSelectionInList = (newVal, oldVal) => {
        const children = dartList.childNodes;
        children[oldVal] && children[oldVal].classList.remove("selected");
        const toSelect = children[newVal];
        toSelect && toSelect.classList.add("selected");
        // the below is somewhat silly, especially for touch devices as putting a dart opens the keyboard
        // toSelect && toSelect.lastChild && toSelect.lastChild.focus(); // selection change -> focus the input
    };
    model.selectedIndex.onChange(showSelectionInList);

    model.segments.onAdd( obsSegment => {
        const dLine = document.createElement("DIV");
        const label = document.createElement("LABEL");
        const input = document.createElement("INPUT");
        input.setAttribute("TYPE", "TEXT");

        input.addEventListener("change", evt => {
            dartController.setSegmentLabel(obsSegment)(input.value);
        });
        const select = evt => dartController.selectIndex([...dartList.childNodes].indexOf(dLine));
        input.addEventListener("focus", select);
        dLine.addEventListener("click", select);

        obsSegment.onChange( segment => {
           label.innerText =  segment.value;
           input.value      = segment.label;
        });

        dLine.appendChild(label);
        dLine.appendChild(input);
        dartList.appendChild(dLine);
    });

    model.segments.onDel( (item, index) => {
        const toDelete = dartList.childNodes[index];
        toDelete && dartList.removeChild(toDelete);
        // we might also need to refresh the selected line in cases where the
        // selected index does not change (therefore no notification) but now a different
        // line is at the selected index position. This happens e.g. when deleting the first segment
        const newIndex = model.selectedIndex.getValue();
        showSelectionInList(newIndex, newIndex);
    });

    // dartView listeners:

    dartView.onclick = evt => {
        updateModelFromEvent(dartView, evt, model, dartController); // we read and write there ...
    };

    model.selectedIndex.onChange( (newVal, oldVal) => {
        dartboard(dartView, model);                         // selection change -> repaint the dartboard
    });

    model.segments.onDel( _ => dartboard(dartView, model)); // segment removed -> repaint dartboard
    model.segments.onAdd( obs => {                          // segment added   ->
        obs.onChange(_ => dartboard(dartView, model));      //   add listener to value changes
        dartboard(dartView, model);                         //   repaint dartboard since we have a new segment to display
    });

    // initial state

    dartController.addSegment( 0, 'Coolness');            // todo: consider [Segment, value, label] = Tuple(2)
    dartController.addSegment( 0, 'Fun');
    dartController.addSegment( 0, 'Ambition');
    dartController.addSegment( 0, 'Drive');

    dartController.selectIndex(0);

</script>

</body>
</html>