<!DOCTYPE html>
<html>
<head>
    <title>View</title>
    <script src="../observable/observable.js"></script>
    <script src="dartboard.js"></script>
    <style>
        body {
            background: palegoldenrod;
        }
        canvas {
            margin: 0.1em 1em 0 1em;
            --dartboard-color-ring0 :    red;
            --dartboard-color-ring1 :    lightblue;
            --dartboard-color-ring2 :    blue;
            --dartboard-color-ring3 :    darkblue;
            --dartboard-color-selected:  black;
            --dartboard-no-color    :    rgba(255,255,255,0.2);
        }
        label {
            padding-right: 0.8em;
        }
        #dartList {
            display: grid;
            grid: auto / auto ;
        }
        div.widget {
            float: left;
        }
        .selected {
            border: 2px solid orange;
            border-radius: 4px;
        }
        footer {
          position: fixed;
          left: 0;
          bottom: 0;
          width: 100%;
          padding: 2em;
        }
    </style>

</head>
<body>


<div class="widget">
    <canvas id="dartView" width="400" height="400"></canvas>
</div>

<div class="widget">
    <div id="dartList"></div>
</div>

<div class="widget">
    <button onclick="dartAPI.addSegment(0,'change me')"> + </button>
    <button onclick="dartAPI.removeSelectedSegment();" > - </button>
</div>

<div class="widget">
    <pre>

    Butterfly ideas:
    - keep the model identities such that the view can bind *read-only* in a stable fashion (observable)
    - keep the view  identities (go around issues with the view state)

    - views never write into the model, they send a command to the controller
    - commands are processed in strict sequence (special issue: callbacks from asynchronous calls)
    - since the controller is the only one that can write into the model, he can also safely read

    - a controller has no access to the view
    - all information that a controller needs must be in the model (from previous commands) or given as command attributes

    --- update:
        - trying to make the controller also the single source for _reading_.
        - if one sees the model as an in-memory data store, the controller works like a DAO to the store.
        - the controller now totally captures the model and exposes a restricted API to it.
        - make the model contained in the controller
        - expose only a segment veneer to the view

    </pre>
</div>

<script>

    const Controller = () => {                          // make a local scope. This will later go into a module

        const model = {                                 // model is local to the controller
            selectedIndex: Observable(-1),              // -1 means no selection, todo: consider Nothing
            segments:      ObservableList([])           // list of Segments entries
        };

        const Segment = (value, label) => {             // veneer
            const valueAttr = Observable(value);
            const labelAttr = Observable(label);
            return {                                    // veneer API
                setValue: valueAttr.setValue,
                getValue: valueAttr.getValue,
                setLabel: labelAttr.setValue,
                getLabel: labelAttr.getValue,
                onValueChange: valueAttr.onChange,
                onLabelChange: labelAttr.onChange,
            }
        };

        const addSegment = (value, label = "change me") => {
            model.segments.add(Segment(value, label));
            selectLastIndex();
        };
        /** private */
        const removeSegment = index => {
            if (! isValidIndex(index)) return;
            model.segments.delIndex(index);
            if (isSelected(index)) {  // business rule: after removal we select the previous segment if any
                selectIndex(index > 0 ? index - 1 : 0);
            }
        };

        const removeSelectedSegment = () => removeSegment(model.selectedIndex.getValue());
        const selectIndex  = index => isValidIndex(index) && model.selectedIndex.setValue(index);
        const isValidIndex = index => (index >=0 && index < model.segments.count());                // private
        const isSelected   = index => index === model.selectedIndex.getValue();                     // private
        const selectLastIndex = () => selectIndex(model.segments.count() - 1);                      // private

        const selectedIndex     = () => model.selectedIndex.getValue();
        const hasValidSelection = () => selectedIndex() > -1;

        const setSegmentByIndexValue = index => model.segments.getAt(index).setValue;
        const setSegmentByIndexLabel = index => model.segments.getAt(index).setLabel;

        return {                                            // public API for the views to work with
            addSegment:             addSegment,
            removeSelectedSegment:  removeSelectedSegment,
            selectIndex:            selectIndex,
            setSegmentByIndexValue: setSegmentByIndexValue,
            setSegmentByIndexLabel: setSegmentByIndexLabel,
            selectedIndex:          selectedIndex,
            hasValidSelection:      hasValidSelection,
            segmentCount:           model.segments.count,
            mapSegments:            model.segments.map,
            onSelectionChange:      model.selectedIndex.onChange,
            onSegmentAdd:           model.segments.onAdd,
            onSegmentDelete:        model.segments.onDel,
        }
    };

    const dartAPI = Controller();

    // register the listeners ------------

    // view constants:
    const dartView     = document.getElementById("dartView");
    const dartList     = document.getElementById("dartList");

    // dartList listeners:

    const showSelectionInList = (newVal, oldVal) => {
        const children = dartList.childNodes;
        children[oldVal] && children[oldVal].classList.remove("selected");
        const toSelect = children[newVal];
        toSelect && toSelect.classList.add("selected");
    };
    dartAPI.onSelectionChange(showSelectionInList);

    dartAPI.onSegmentAdd( segment => {
        const dLine = document.createElement("DIV");
        dLine.innerHTML = `
            <LABEL></LABEL>
            <INPUT TYPE="TEXT">
        `;
        const [label, input] = dLine.children;

        input.addEventListener("change", evt => {
            segment.setLabel(input.value);
        });
        const select = evt => dartAPI.selectIndex([...dartList.childNodes].indexOf(dLine));
        input.addEventListener("focus", select);
        dLine.addEventListener("click", select);

        segment.onValueChange( value => label.innerText = value);
        segment.onLabelChange( label => input.value     = label);

        dartList.appendChild(dLine);
    });

    dartAPI.onSegmentDelete( (item, index) => {
        const toDelete = dartList.childNodes[index];
        toDelete && dartList.removeChild(toDelete);
        // we might also need to refresh the selected line in cases where the
        // selected index does not change (therefore no notification) but now a different
        // line is at the selected index position. This happens e.g. when deleting the first segment
        const newIndex = dartAPI.selectedIndex();
        showSelectionInList(newIndex, newIndex);
    });

    // dartView listeners:

    dartView.onclick = evt => {
        updateModelFromEvent(dartView, evt, dartAPI);
    };

    dartAPI.onSelectionChange( _ => dartboard(dartView, dartAPI) );  // selection change -> repaint the dartboard

    dartAPI.onSegmentDelete( _ => dartboard(dartView, dartAPI)); // segment removed -> repaint dartboard
    dartAPI.onSegmentAdd( segment => {                                  // segment added   ->
        segment.onValueChange(_ => dartboard(dartView, dartAPI));      //   add listener to value changes
        dartboard(dartView, dartAPI);                                   //   repaint dartboard since we have a new segment to display
    });

    // initial state

    dartAPI.addSegment( 0, 'Coolness');
    dartAPI.addSegment( 0, 'Fun');
    dartAPI.addSegment( 0, 'Ambition');
    dartAPI.addSegment( 0, 'Drive');

    dartAPI.selectIndex(0);

</script>

<footer>
    Design: Team Quickfeedback, <a href="http://fhnw.ch">FHNW</a>
</footer>
</body>
</html>