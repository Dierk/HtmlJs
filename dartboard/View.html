<!DOCTYPE html>
<html>
<head>
    <title>View</title>
    <script src="../observable/observable.js"></script>
    <script src="dartboard.js"></script>
    <style>
        body {
            background: palegoldenrod;
        }
        canvas {
            margin: 0.1em 1em 0 1em;
            --dartboard-color-ring0 :    red;
            --dartboard-color-ring1 :    lightblue;
            --dartboard-color-ring2 :    blue;
            --dartboard-color-ring3 :    darkblue;
            --dartboard-color-selected:  black;
            --dartboard-no-color    :    rgba(255,255,255,0.2);
        }
        label {
            padding-right: 0.8em;
            padding-left:  0.8em;
        }
        #dartList {
            display: grid;
            grid: auto / auto ;
        }
        div.widget {
            float: left;
        }
        .selected {
            border: 2px solid orange;
            border-radius: 4px;
        }
    </style>

</head>
<body>


<div class="widget">
    <canvas id="dartView" width="400" height="400"></canvas>
</div>

<div class="widget">
    <div id="dartList"></div>
</div>

<div class="widget">
    <button onclick="dartAPI.addSegment(0,'change me')"> add and select segment</button>
    <button onclick="dartAPI.removeSelectedSegment();"> remove selected segment</button>
</div>

<div class="widget">
    <pre>

    Butterfly ideas:
    - keep the model identities such that the view can bind *read-only* in a stable fashion (observable)
    - keep the view  identities (go around issues with the view state)

    - views never write into the model, they send a command to the controller
    - commands are processed in strict sequence (special issue: callbacks from asynchronous calls)
    - since the controller is the only one that can write into the model, he can also safely read

    - a controller has no access to the view
    - all information that a controller needs must be in the model (from previous commands) or given as command attributes

    --- update:
        - trying to make the controller also the single source for _reading_.
        - if one sees the model as an in-memory data store, the controller works like a DAO to the store.
        - the controller now totally captures the model and exposes a restricted API to it.

    </pre>
</div>

<script>

    // Controller      // dependency injection done right :-)
    const Controller = model => {                           // make a local scope. This will later go into a module

        const addSegment = (value, label = "change me") => {
            model.segments.add({value: Observable(value), label: Observable(label)});
            selectLastIndex();
        };
        /** private */
        const removeSegment = index => {
            if (! isValidIndex(index)) return;
            model.segments.delIndex(index);
            if (isSelected(index)) {  // business rule: after removal we select the previous segment if any
                selectIndex(index > 0 ? index - 1 : 0);
            }
        };

        const removeSelectedSegment = () => removeSegment(model.selectedIndex.getValue());
        const selectIndex  = index => isValidIndex(index) && model.selectedIndex.setValue(index);
        const isValidIndex = index => (index >=0 && index < model.segments.count());                // private
        const isSelected   = index => index === model.selectedIndex.getValue();                     // private
        const selectLastIndex = () => selectIndex(model.segments.count() - 1);                      // private

        const segmentCount      = () => model.segments.count();
        const selectedIndex     = () => model.selectedIndex.getValue();
        const hasValidSelection = () => selectedIndex() > -1;

        const setSegmentValue = segment => value => segment.value.setValue(value);
        const setSegmentLabel = segment => label => segment.label.setValue(label);

        const setSegmentByIndexValue = index => setSegmentValue(model.segments.getAt(index));
        const setSegmentByIndexLabel = index => setSegmentLabel(model.segments.getAt(index));

        const unwrap = obj => { // unwrap an obj of Observable properties to raw values             // private
            Object.keys(obj).reduce( (accu, key) => {accu[key] = obj[key].getValue(); return accu}, {});
        };
        // allow mapping over segments in a read-only fashion, exposing only the raw data
        const mapSegments = (...args) => model.segments.map( unwrap ).map(...args);


        // public API for the views to work with
        return {
            addSegment:             addSegment,
            removeSelectedSegment:  removeSelectedSegment,
            selectIndex:            selectIndex,
            setSegmentValue:        setSegmentValue,
            setSegmentLabel:        setSegmentLabel,
            setSegmentByIndexValue: setSegmentByIndexValue,
            setSegmentByIndexLabel: setSegmentByIndexLabel,
            segmentCount:           segmentCount,
            selectedIndex:          selectedIndex,
            hasValidSelection:      hasValidSelection,
            mapSegments:            mapSegments,
            onSelectionChange:      model.selectedIndex.onChange,
            onSegmentAdd:           model.segments.onAdd,
            onSegmentDelete:        model.segments.onDel,
        }
    };

    const dartAPI = Controller( {    // model is local to the controller
        selectedIndex: Observable(-1),      // -1 means no selection, todo: consider Nothing
        segments:      ObservableList([])   // list of {value: Observable , label: Observable} entries
    });

    // below here, the model is no longer used for _reading_, only for setting up the listeners

    // register the listeners ------------

    // view constants:
    const dartView = document.getElementById("dartView");
    const dartList = document.getElementById("dartList");

    // dartList listeners:

    const showSelectionInList = (newVal, oldVal) => {
        const children = dartList.childNodes;
        children[oldVal] && children[oldVal].classList.remove("selected");
        const toSelect = children[newVal];
        toSelect && toSelect.classList.add("selected");
        // the below is somewhat silly, especially for touch devices as putting a dart opens the keyboard
        // toSelect && toSelect.lastChild && toSelect.lastChild.focus(); // selection change -> focus the input
    };
    dartAPI.onSelectionChange(showSelectionInList);

    dartAPI.onSegmentAdd( segment => {
        const dLine = document.createElement("DIV");
        const label = document.createElement("LABEL");
        const input = document.createElement("INPUT");
        input.setAttribute("TYPE", "TEXT");

        input.addEventListener("change", evt => {
            dartAPI.setSegmentLabel(segment)(input.value);
        });
        const select = evt => dartAPI.selectIndex([...dartList.childNodes].indexOf(dLine));
        input.addEventListener("focus", select);
        dLine.addEventListener("click", select);

        segment.value.onChange( value => label.innerText = value);
        segment.label.onChange( label => input.value     = label);

        dLine.appendChild(label);
        dLine.appendChild(input);
        dartList.appendChild(dLine);
    });

    dartAPI.onSegmentDelete( (item, index) => {
        const toDelete = dartList.childNodes[index];
        toDelete && dartList.removeChild(toDelete);
        // we might also need to refresh the selected line in cases where the
        // selected index does not change (therefore no notification) but now a different
        // line is at the selected index position. This happens e.g. when deleting the first segment
        const newIndex = dartAPI.selectedIndex();
        showSelectionInList(newIndex, newIndex);
    });

    // dartView listeners:

    dartView.onclick = evt => {
        updateModelFromEvent(dartView, evt, dartAPI);
    };

    dartAPI.onSelectionChange( _ => dartboard(dartView, dartAPI) );  // selection change -> repaint the dartboard

    dartAPI.onSegmentDelete( _ => dartboard(dartView, dartAPI)); // segment removed -> repaint dartboard
    dartAPI.onSegmentAdd( segment => {                                  // segment added   ->
        segment.value.onChange(_ => dartboard(dartView, dartAPI));      //   add listener to value changes
        dartboard(dartView, dartAPI);                                   //   repaint dartboard since we have a new segment to display
    });

    // initial state

    dartAPI.addSegment( 0, 'Coolness');            // todo: consider [Segment, value, label] = Tuple(2)
    dartAPI.addSegment( 0, 'Fun');
    dartAPI.addSegment( 0, 'Ambition');
    dartAPI.addSegment( 0, 'Drive');

    dartAPI.selectIndex(0);

</script>

</body>
</html>